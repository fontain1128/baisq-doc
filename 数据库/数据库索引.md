# 索引

数据库的索引包含两种数据结构，B+树索引以及Hash索引。

# B+树

B+树是n叉排序树，每个节点有多个孩子，一棵B+树包含根节点，内部节点和叶子节点。只有最底层的叶子节点才保存信息，内部节点只是在搜索中用来指引到正确节点的，而且到任何一个叶子节点的最短路径长度都是相同的O\(logn\)。

![](/assets/B+Tree.jpg)  
使用B+树查找特定值的时间复杂度为O\(logn\)，当需要查找两个值之间的多个元素时，通过对叶子节点之间的相连，也使得范围查询更加高效。

如上图，假设查找10到100间的值：

只需要按B+树的最短路径找到10（若10不存在则找10之后最贴近的值）

然后用那些连接来收集10的后续节点，直到找到100

归纳一下，假设需要找M个后续节点，树总共有N个节点，那么这次搜索只需要消耗M+logN。

但对于在数据库中增加或删除一行，B+树需要自我整理和平衡，需要O\(logN\)时间复杂度，所以使用太多的B+索引，减慢了快速插入，更新，删除表中一行的操作速度。

# Hash索引

Hash索引对特定值的检索效率很高，索引检索一次一般即可定位，不像B+索引需要从根节点到叶子节点，需要O\(logN\)次的IO访问。

但以Mysql为例，查询资料如下表：

| 描述 | innoDB | MyISAM | Memory | Archive |
| :--- | :--- | :--- | :--- | :--- |
| 事务 | 支持事务，行级别锁定 | 不支持，表级别锁定 | 不支持，表级别锁定 | 不支持，表级别锁定 |
| 索引 | B+Tree | B+Tree | B+Tree以及Hash | 不支持 |

对于常用的innoDB以及MyISAM引擎，均不支持Hash索引，因其自身存在的诸多弊端

Hash索引仅仅能满足“=”，“IN”，“<=>”查询，不能使用范围查询

Hash索引无法用来进行数据的排序操作

Hash索引不能利用联合索引键查询，因为计算组合索引，Hash值是将键合并后再一起Hash，不能单独计算Hash值，所以对于联合索引前几个键进行查询时，Hash索引无法被利用

Hash索引计算的Hash值若不够松散，存在大量Hash值相等的情况下，不能避免表扫描，性能也不一定好于B+树

# 有关索引
## 聚集索引
聚集索引决定数据在磁盘上的物理排序，一个表只能有一个聚集索引，一般用primary key（pk 主键）来命名
## 非聚集索引
以mysql为例，非聚集索引分为普通索引（index）和唯一索引（unique）

非聚集索引并不决定数据在磁盘上的物理排序，索引只包含被建立索引的数据，以及一个行定位符row-locator，这个行定位符可以理解为一个聚集索引物理排序的指针，通过这个指针，可以找到行数据
## 联合索引
多个字段上建立的索引，能够加速复合查询条件的检索，联合索引能够满足最左侧查询需求，例如（x,y,z）三列索引，能够使x 或 x,y 或 x,y,z使用上索引，需要注意的是最左侧查询需求，并不是指SQL语句的写法必须满足索引顺序，SQL优化会自动调整以满足联合索引的顺序的，如zyx会被自动优化为xyz以便使用联合索引加速查询
## sql的where条件提取
SQL的where条件，均可归纳为三大类：Index Key（First Key & Last Key），Index Filter，Table Filter，按照从前到后的顺序获取查询的数据

例子：select * from t where a >= 3 and a < 6 and b > 5 and c!=3 and d !=9
联合索引[a,b,c]

**Index Key**：

用于确定SQL查询在索引中的范围，由于一个范围，至少包含一个起始与一个终止，分别用于定位索引查询的起始以及索引查询的终止条件；

MySQL利用=、>=、> 来确定下边界（first key），利用最左原则，首先判断第一个索引键值在where条件中是否存在，如果存在，则判断比较符号，如果为(=,>=)中的一种，加入下边界的界定，然后继续判断下一个索引键，如果存在且是(>)，则将该键值加入到下边界的界定，停止匹配下一个索引键；如果不存在，直接停止下边界匹配，因此上面的例子，下边界为 a>=3 and b>5

判断上边界方法与下边界相反，上面例子的上边界为 a<6,最终确定Index Key的范围是a>=3 and a < 6

**Index Filter**：

简单来说，就是无法用Index key确定部分的索引可以当做Index Filter，当然是需要满足最左原则的，即从第一列索引往后看，若第一列索引包括查询条件‘=’，或者有index key可以跳过看下一列索引

本例子中的Index Filter即为b> 5 and c!=3

**Table Filter**：

经过Index Key 和Index Filter过滤后，所有不属于索引列的查询条件，均归为Table Filter之中，通过前面两部过滤后，使得需要回表查询的数据大量减少，提高了查询的效率，本例子为 d!=9

## 有关between和like使用索引

**Between**：

where a between 10 and 100 可以转变为 where a > 10 and a <100,作为index key进行索引查询

**like**：

like需要注意的是%不能是在最左侧，where d like ‘%a’ 这样的查询是无法利用索引的，因为索引的匹配需要符合最左前缀原则

## 索引的结果排序

若联合索引为[a,b,c]，a是有序的，若a为固定的值，则b有序，依次类推


